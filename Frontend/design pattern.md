# design pattern

### 소프트웨어 아키텍처와 디자인 패턴의 차이

소프트웨어 아키텍처: 유연성, 확장성, 실현가능성, 재사용성, 보안성과 같은 소프트웨어의 특성들을 기술적, 사업적 기대사항에 맞는 구조화된 솔루션으로 만들어가는 과정으로 아키텍처 특성, 아키텍처 결정, 설계 원칙이 결합된 시스템의 구조

- 아키텍처 특성: 시스템의 기능과 직교하는 시스템의 성공 기준 (성능, 확장성, 신뢰성, 활용성, 유지보수성, 접슨성, 보안성, 사용성 등)
- 아키텍처 결정: 시스템 구축에 필요한 규칙들을 정하는 것. 시스템의 제약 조건을 형성
- 설게 원칙: 시스템 구축에 필요한 가이드라인을 정하는 것.

소프트웨어 디자인 패턴: 코드 레벨의 디자인(각각의 모듈이 어떤 역할을 수행하는지, 클래스 범위, 함수의 목적 등) 소프트웨어의 특정 구현을 직접 제공하지는 않지만, 반복되는 문제 상황들을 최적화된 방법으로 해결하도록 돕는 역할

각각의 정의를 살펴보면 디자인 패턴은 소프트웨어 아키텍처보다 작은 범위에 속하는 어떻게 코드를 작성할 것인가에 대한 방법론이라고 할 수 있을 것 같다.

### MVC 패턴

MVC 패턴은 Model - View - Controller 이다.

- Model: 데이터와 비즈니스 로직 영역
- View: UI, 유저가 직접 마주하는 화면
- Controller: Model과 View의 조율자 역할. View로 부터 유저의 입력이 들어오면, Model의 데이터를 핸들링하여 결과를 다시 View로 보내는 역할

MVC 패턴에서의 View는 그냥 단순히 화면을 보여주는 역할로 정의한 반면에 프론트엔드에서는 그 View에서 발생하는 수많은 이벤트를 처리하는 것이 중요하다. 그럼 이게 View인지 Controller인지 개념도 모호해진다. 또 현재 프론트엔드 개발을 할 때에는 많은 View가 존재하고 또 각각의 View에서 필요한 데이터가 많고, View에서 Model과 직접 소통이 필요한 경우도 많을텐데, Controller를 통해 접근할 수 밖에 없다면 Controller도 굉장히 커질 것 같다.

### MVVM 패턴

MVVM은 MVC에서 Model, View, ViewModel로 바뀌었다. 이중 Controller가 ViewModel로 바뀐게 가장 큰 부분인데 기존의 Controller는 View에서 데이터를 요청할 때마다 기능을 반복적으로 수행했다면, Model에서 데이터가 변경되면 View에서도 자동으로 바뀐다. 그런데 이러한 MVVM 패턴도 많은 View가 계층적으로 존재하기 때문에, 데이터를 공유하면서 발생하는 Props Drilling Problem 문제점을 해결하지는 못했다.

### Redux와 Flux 패턴

View에서 어떠한 입력을 통해 Action을 호출하게 되면 그 Action이 Dispatch를 통해 다시 store에 데이터를 전달하고, store에서 변경사항이 있으면 다시 View가 바뀌는 이러한 단방향적인 구조를 가진다.
이러한 Flux 패턴으로인해 Redux가 등장하였다. 기존의 문제점이었던 Props Drilling Problem의 문제점을 해결하면서, Store, Dispatch, Reducer의 개념을 명확히 했다. 하지만 이러한 Redux도 보일러플레이트가 너무 많다는 문제가 있다.

### Atomic 패턴

View를 원자(Atoms), 분자(Molecules), 유기체(Organisms), 템플릿(Templates), 페이지(Pages) 순으로 작은 것들을 만들고 결합해 더 큰 단위의 View를 그리는 방법이다.

- 원자 : button, input, font 등 가장 작은 구성요소
- 분자 : 여러 개의 원자 요소의 구성으로, 여기서부터 복잡한 요소를 구성하고 재사용하기 시작함
- 유기체 : 사용자에게 더 의미 있는 정보를 제공하거나 인터랙션하는 정교한 인터페이스를 구성하는 원자 또는 분자의 조합
- 템플릿 : 실제 콘텐츠가 입혀지기 전에 정해지는 와이어 프레임
- 페이지 : 완성된 최종 View

이러한 아토믹 패턴에서 Atoms 개념을 따온 것이 Recoil 라이브러리에 도입되었는데, Recoil은 Redux 보다 간단한 문법으로 컴포넌트 외부에서 공통의 데이터를 set, get 할 수 있게 하면서 동시에 동기화를 할 수 있게 한다. 또한 Redux보다 성능적으로 우수하며 (O(1), Redux는 O(n)), 사용하기에 따라 상태 정의의 유지 관리가 더 쉬울 수 있다. (중앙집중식 vs 분산관리식). 단점은 미들웨어가 존재하지 않기 때문에 때에 따라 사용하기 적합하지 않는 환경이 있을 수 있다.
